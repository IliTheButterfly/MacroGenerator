from __future__ import annotations
from enum import Enum
from collections import deque
from itertools import repeat
from tkinter import Variable
from typing import Any, Callable, Generic, List, Literal, LiteralString, Set, TypeVar, Union, overload

import pyperclip


PLC_NAME = "Rockwell EtherNet/IP (CompactLogix)"
HMI_NAME = "Local HMI"

header = """GENERATED CODE
This code was generated by a script.
See https://github.com/IliTheButterfly/MacroGenerator"""

DT = TypeVar('DT')



dt = Literal['bool', 'unsigned char', 'char', 'unsigned short', 
             'short', 'unsigned int', 'int', 'unsigned long', 'long', 'float', 'double']

class Resource:
    def __init__(self, *resources:Resource):
        self.resources:List[Resource] = list(resources)
    def process(self, macro:Macro) -> None:
        for r in self.resources:
            if isinstance(r, Resource) and not r.__class__ is Resource:
                r.process(macro)
    
class STATEMENT(Resource):
    def __init__(self, *resources:Resource):
        super().__init__(resources)
        
    def __str__(self) -> str: ...

    def process(self, macro:Macro):
        super().process(macro)
        
    def bake(self, macro:Macro):
        macro.write_raw(str(self))
        
class EMPTY(STATEMENT):
    def __init__(self):
        super().__init__()
        
    def __str__(self) -> str:
        return '\n'

class BASE_STATEMENT(STATEMENT):
    def __init__(self, value:str=None):
        super().__init__()
        self._res = value
        
    def __str__(self) -> str:
        if self._res is None:
            return '\n'
        return self._res + '\n'

class COMMENT(STATEMENT):
    def __init__(self, text:str):
        super().__init__()
        self.text = text
        
    def __str__(self) -> str:
        return ''.join([f'// {l}\n' for l in self.text.splitlines(False)])

class C_IF(STATEMENT):
    def __init__(self, condition:Union[EXPRESSION, Variable[bool]]):
        super().__init__()
        if isinstance(condition, Variable):
            condition = condition.as_literal()
        self.condition = condition
        
    def __str__(self) -> str:
        return f'if {str(self.condition)} then\n'
    
    def process(self, macro: Macro):
        self.condition.process(macro)
        super().process(macro)
    
    def bake(self, macro:Macro):
        super().bake(macro)
        macro._open_if()

class CONDITION_BLOCK(STATEMENT):
    def __init__(self, *content:STATEMENT):
        super().__init__()
        self.content:List[STATEMENT] = list([*content])

class COMPLETED_CONTAINER(STATEMENT):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__()
        self._parent = parent
        
    def process(self, macro: Macro):
        self._parent.process(macro)

    def bake(self, macro: Macro):
        self._parent.bake(macro)

class ELSE_CONTAINER(CONDITION_BLOCK):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__(*parent.content)
        self._empty = True
        
    def __call__(self, *body:STATEMENT) -> COMPLETED_CONTAINER:
        self._empty = False
        self.content.append(C_ELSE())
        self.content.extend(body)
        self.content.append(C_END_IF())
        return COMPLETED_CONTAINER(self)
        
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._empty:
            C_END_IF().bake(macro)

class ELIF_CONTAINER(CONDITION_BLOCK):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__(*parent.content)
        self._parent = parent
        self._empty = True
        
    def __call__(self, *body:STATEMENT) -> IF_CONTAINER:
        self._empty = False
        self.content.extend(body)
        return IF_CONTAINER(self)
    
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._empty:
            C_END_IF().bake(macro)


class IF_CONTAINER(CONDITION_BLOCK):
    def __init__(self, parent:CONDITION_BLOCK):
        super().__init__(*parent.content)
        self._parent = parent
        self._ends = True
        
    def ELSE(self) -> ELSE_CONTAINER:
        self._ends = False
        return ELSE_CONTAINER(self)
    
    def ELIF(self, condition:EXPRESSION) -> ELIF_CONTAINER:
        self.content.append(C_ELIF(condition))
        return ELIF_CONTAINER(self)
    
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._ends:
            C_END_IF().bake(macro)

class IF(CONDITION_BLOCK):
    def __init__(self, condition:EXPRESSION):
        super().__init__(C_IF(condition))
        self._empty = True
        
    def __call__(self, *body:STATEMENT) -> IF_CONTAINER:
        self._empty = False
        self.content.extend(body)
        return IF_CONTAINER(self)
    
    def process(self, macro: Macro):
        for s in self.content:
            s.process(macro)
        super().process(macro)
        
    def bake(self, macro: Macro):
        for s in self.content:
            s.bake(macro)
        if self._empty:
            C_END_IF().bake(macro)
        
    
class C_ELSE(STATEMENT):
    def __init__(self):
        super().__init__()
    
    def __str__(self) -> str:
        return 'else\n'
    
    def bake(self, macro:Macro):
        macro._close_if()
        super().bake(macro)
        macro._open_if()

class C_ELIF(STATEMENT):
    def __init__(self, condition:Union[EXPRESSION, Variable[bool]]):
        super().__init__()
        if isinstance(condition, Variable):
            condition = condition.as_literal()
        self.condition = condition
    
    def __str__(self) -> str:
        return f'else if {str(self.condition)} then\n'
    
    def process(self, macro: Macro):
        self.condition.process(macro)
        super().process(macro)
    
    def bake(self, macro:Macro):
        macro._close_if()
        super().bake(macro)
        macro._open_if()


class C_END_IF(STATEMENT):
    def __init__(self):
        super().__init__()
    
    def __str__(self) -> str:
        return 'end if\n'
    
    def bake(self, macro:Macro):
        macro._close_if()
        super().bake(macro)

class BLOCK(STATEMENT):
    def __init__(self, *statements:STATEMENT):
        super().__init__(*statements)
        self.statements = statements
    
    def bake(self, macro):
        for s in self.statements:
            s.bake(macro)

class VARIABLE_BLOCK(STATEMENT):
    def __init__(self):
        super().__init__()
        
    def bake(self, macro: Macro):
        for v in macro.variables:
            macro.write_raw(v.declare(), '\n')

class BEGIN_MACRO(STATEMENT):
    def __init__(self):
        super().__init__()
    
    def __str__(self) -> str:
        return 'macro_command main()\n'
    
    def bake(self, macro:Macro):
        super().bake(macro)
        macro._open_macro()

class END_MACRO(STATEMENT):
    def __init__(self):
        super().__init__()
    
    def __str__(self) -> str:
        return 'end macro_command\n'
    
    def bake(self, macro:Macro):
        macro._close_macro()
        super().bake(macro)

class ASSIGNEMENT(STATEMENT):
    def __init__(self, var:Variable[DT], value:Any):
        super().__init__()
        self.var = var
        self.value = value
        
    def __str__(self) -> str:
        return f'{self.var} = {str(self.value)}\n'

    def process(self, macro: Macro):
        self.var.process(macro)
        if isinstance(self.value, Resource):
            self.value.process(macro)
        super().process(macro)
    
def string_literal(v:str) -> str:
    if not v.startswith('"'):
        v = '"' + v
    if not v.endswith('"'):
        v += '"'
    return v

class CALL(STATEMENT):
    def __init__(self, funcName: str, *params:Union[Variable, bool, int, float, str]):
        super().__init__()
        self.funcName = funcName
        self.params:List[Union[Variable, bool, int, float, str]] = list([*params])
    
    def __str__(self) -> str:
        for i, p in enumerate(self.params):
            if isinstance(p, str):
                self.params[i] = string_literal(p)
        return f'{self.funcName}({", ".join([str(p) for p in self.params])})\n'
    
    def process(self, macro: Macro):
        for p in self.params:
            if isinstance(p, Resource):
                p.process(macro)
        super().process(macro)

class RETURN(STATEMENT):
    def __init__(self, ret:Union[EXPRESSION, Variable, bool, int, float, str, None] = None):
        super().__init__()
        self.ret = ret
    
    def __str__(self) -> str:
        if self.ret is None:
            return 'return'
        return f'return {str(self.ret)}'

    def process(self, macro: Macro):
        if isinstance(self.ret, Resource):
            self.ret.process(macro)
        super().process(macro)

class BREAK(STATEMENT):
    def __init__(self):
        super().__init__()
        
    def __str__(self) -> str:
        return 'break'

class CONTINUE(STATEMENT):
    def __init__(self):
        super().__init__()
        
    def __str__(self) -> str:
        return 'continue'
    
class EXPRESSION(Resource):
    def __init__(self, *exps:EXPRESSION):
        super().__init__(*exps)
    
    def __and__(self, other:Union[EXPRESSION, Variable[bool]]) -> EXPRESSION:
        if isinstance(other, Variable):
            other = other.as_literal()
        return AND(self, other)
    
    def __or__(self, other:Union[EXPRESSION, Variable[bool]]) -> EXPRESSION:
        if isinstance(other, Variable):
            other = other.as_literal()
        return OR(self, other)
    
    def __invert__(self) -> EXPRESSION:
        return NOT(self)
    
    def __str__(self) -> str: ...
    
class LITERAL(EXPRESSION):
    def __init__(self, literal:str):
        super().__init__()
        self.literal = literal
        
    def __str__(self) -> str:
        return self.literal
    
    def __repr__(self):
        return f"[{self.literal}]"
    
class NOT(EXPRESSION):
    def __init__(self, expression:EXPRESSION):
        super().__init__(expression)
        self.expression = expression.as_literal() if isinstance(expression, Variable) else expression
        
    def __invert__(self) -> EXPRESSION:
        return self.expression
        
    def __str__(self) -> str:
        return f'(not {self.expression})'
    
    def __repr__(self):
        return f'NOT [{repr(self.expression)}]'
    
class OR(EXPRESSION):
    def __init__(self, *expressions:EXPRESSION):
        super().__init__(*expressions)
        self._expressions:List[EXPRESSION] = [*[(e.as_literal() if isinstance(e, Variable) else e) for e in expressions]]
    
    def __or__(self, other:Union[EXPRESSION, Variable[bool]]) -> OR:
        if isinstance(other, Variable):
            other = other.as_literal()
        if isinstance(other, OR):
            return OR(*self._expressions, *other._expressions)
        return super().__or__(self, other)
    
    def append(self, *expressions:EXPRESSION):
        self._expressions.extend(expressions)
        self.resources.extend(expressions)
        
    def __str__(self):
        return f'({" or ".join([str(e) for e in self._expressions])})'
        
    def __repr__(self):
        return f'[{" OR ".join([repr(e) for e in self._expressions])}]'
        
class AND(EXPRESSION):
    def __init__(self, *expressions:Union[EXPRESSION, Variable[bool]]):
        super().__init__(*expressions)
        self._expressions:List[EXPRESSION] = [*[(e.as_literal() if isinstance(e, Variable) else e) for e in expressions]]
        
    def __and__(self, other:EXPRESSION) -> AND:
        if isinstance(other, Variable):
            other = other.as_literal()
        if isinstance(other, AND):
            return AND(*self._expressions, *other._expressions)
        return super().__and__(other)
        
    def append(self, *expressions:EXPRESSION):
        self._expressions.extend(expressions)
        self.resources.extend(expressions)
        
    def __str__(self):
        return f'({" and ".join([str(e) for e in self._expressions])})'
        
    def __repr__(self):
        return f'[{" AND ".join([repr(e) for e in self._expressions])}]'

class Variable(Resource, Generic[DT]):
    def __init__(self, name:str, dtype:dt, default:DT=None):
        Resource.__init__(self)
        self.name = name
        self.dtype = dtype
        self.default = default
        
    def process(self, macro:Macro) -> None:
        Resource.process(self, macro)
        macro.add_variable(self)
        
    def as_literal(self) -> LITERAL:
        res = LITERAL(str(self))
        res.resources.append(self)
        return res
        
    def declare(self) -> str:
        if self.default is None:
            return f'{self.dtype} {self.name}'
        return f'{self.dtype} {self.name} = {self.default}'
    
    @overload
    def __eq__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} == {o}')
    
    def __eq__(self, o:Union[Variable, EXPRESSION]) -> LITERAL:
        self.resources.append(o)
        return LITERAL(f'{self.name} == {str(o)}')
    
    @overload
    def __ne__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} <> {o}')
    
    def __ne__(self, o:Union[Variable, EXPRESSION]) -> LITERAL:
        self.resources.append(o)
        return LITERAL(f'{self.name} <> {str(o)}')
    
    @overload
    def __lt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} < {o}')
    
    def __lt__(self, o:Union[Variable, EXPRESSION]) -> LITERAL:
        self.resources.append(o)
        return LITERAL(f'{self.name} < {str(o)}')

    @overload
    def __le__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} <= {o}')
    
    def __le__(self, o:Union[Variable, EXPRESSION]) -> LITERAL:
        self.resources.append(o)
        return LITERAL(f'{self.name} <= {str(o)}')
    
    @overload
    def __gt__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} > {o}')
    
    def __gt__(self, o:Union[Variable, EXPRESSION]) -> LITERAL:
        self.resources.append(o)
        return LITERAL(f'{self.name} > {str(o)}')
    
    @overload
    def __ge__(self, o:Union[int, float, bool, str]) -> LITERAL:
        return LITERAL(f'{self.name} >= {o}')
    
    def __ge__(self, o:Union[Variable, EXPRESSION]) -> LITERAL:
        self.resources.append(o)
        return LITERAL(f'{self.name} >= {str(o)}')
    
    def __and__(self, o:Union[EXPRESSION, Variable[bool]]) -> AND:
        return AND(self, o)
    
    def __or__(self, o:Union[EXPRESSION, Variable[bool]]) -> OR:
        return OR(self, o)
    
    def __invert__(self) -> NOT:
        return NOT(self)
    
    def __sub__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} - {str(o)}')
        res.resources.append(self)
        if isinstance(o, Resource):
            res.resources.append(o)
        return res
    
    def __add__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} + {str(o)}')
        res.resources.append(self)
        if isinstance(o, Resource):
            res.resources.append(o)
        return res
    
    def __mul__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} * {str(o)}')
        res.resources.append(self)
        if isinstance(o, Resource):
            res.resources.append(o)
        return res
    
    def __truediv__(self, o) -> LITERAL:
        res = LITERAL(f'{str(self)} / {str(o)}')
        res.resources.append(self)
        if isinstance(o, Resource):
            res.resources.append(o)
        return res

    def set(self, o:Union[Variable, EXPRESSION, bool, int, float, str]) -> ASSIGNEMENT:
        return ASSIGNEMENT(self, o)

    def __hash__(self) -> int:
        return self.name.__hash__()
    
    def __str__(self) -> str:
        return self.name


def vuchar(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned char', default)
def vchar(name:str, default:int = None) -> Variable[int]: return Variable(name, 'char', default)
def vushort(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned short', default)
def vshort(name:str, default:int = None) -> Variable[int]: return Variable(name, 'short', default)
def vuint(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned int', default)
def vint(name:str, default:int = None) -> Variable[int]: return Variable(name, 'int', default)
def vulong(name:str, default:int = None) -> Variable[int]: return Variable(name, 'unsigned long', default)
def vlong(name:str, default:int = None) -> Variable[int]: return Variable(name, 'long', default)
def vbool(name:str, default:bool = None) -> Variable[bool]: return Variable(name, 'bool', default)
def vfloat(name:str, default:float = None) -> Variable[float]: return Variable(name, 'float', default)
def vdouble(name:str, default:float = None) -> Variable[float]: return Variable(name, 'double', default)

class BlockType(Enum):
    IF_BLOCK = 0
    WHILE_BLOCK = 1
    FOR_BLOCK = 2
    MACRO_BLOCK = 3

class Macro:
    def __init__(self, name:str, description:str):
        self.name = name
        self.description = description
        self.indentation = 0
        self._maxlen = 200
        self.statements:List[STATEMENT] = []
        self.result:List[str] = ['']
        self.variables:Set[Variable] = set()
        self._nest:deque[BlockType] = deque()
        self._variable_block = VARIABLE_BLOCK()
    
    def add_variable(self, var:Variable[DT]) -> Variable[DT]:
        self.variables.add(var)
    
    def write_raw(self, *values:str):
        v = ''.join([str(vv) for vv in values])
        for l in v.splitlines():
            l = ''.join(repeat('    ', self.indentation)) + l + '\n'
            if (len(l) + len(self.result[-1])) > self._maxlen:
                self.result.append(l)
            else:
                self.result[-1] += l
    
    def write(self, *statements:STATEMENT):
        self.statements.extend(statements)
                
    def _open_if(self):
        self._nest.append(BlockType.IF_BLOCK)
        self.indentation += 1
        
    def _close_if(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close if, no if opened.')
        if self._nest[-1] != BlockType.IF_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def _open_macro(self):
        self._nest.append(BlockType.MACRO_BLOCK)
        self.indentation += 1
        
    def _close_macro(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close macro, no macro opened.')
        if self._nest[-1] != BlockType.MACRO_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def _open_while(self):
        self._nest.append(BlockType.WHILE_BLOCK)
        self.indentation += 1
        
    def _close_while(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close while, no while opened.')
        if self._nest[-1] != BlockType.WHILE_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def _open_for(self):
        self._nest.append(BlockType.FOR_BLOCK)
        self.indentation += 1
        
    def _close_for(self):
        if len(self._nest) == 0:
            raise SyntaxError('Unable to close for, no for opened.')
        if self._nest[-1] != BlockType.FOR_BLOCK:
            raise SyntaxError(f'{self._nest[-1].name} not closed.')
        self._nest.pop()
        self.indentation -= 1
        
    def begin(self):
        self.write(
            COMMENT(header),
            EMPTY(),
            EMPTY(),
            COMMENT(self.description),
            BEGIN_MACRO(),
            self._variable_block,
            EMPTY(),
        )
        
    def end(self):
        self.write(END_MACRO())
    
    def display(self):
        self.result = ['']
        for s in self.statements:
            s.process(self)
        
        for s in self.statements:
            s.bake(self)
        
        for l in self.result:
            print(l, end='')
            
    def clipboard(self):
        self.result = ['']
        for s in self.statements:
            s.process(self)
        
        for s in self.statements:
            s.bake(self)
        pyperclip.copy(''.join(self.result))
        

class CONDITIONAL(STATEMENT):
    def __init__(self, condition:Union[bool, Callable[[], bool]], 
                 onTrue:List[STATEMENT]=None, onFalse:List[STATEMENT]=None):
        super().__init__()
        self.condition = condition
        self.onTrue = onTrue
        self.onFalse = onFalse
        
    @property
    def result(self) -> bool:
        if callable(self.condition):
            return self.condition()
        return self.condition
        
    def process(self, macro:Macro):
        if self.result:
            if self.onTrue is not None:
                for s in self.onTrue:
                    s.process(macro)
        else:
            if self.onFalse is not None:
                for s in self.onFalse:
                    s.process(macro)
        super().process(macro)
    
    def bake(self, macro:Macro):
        if self.result:
            if self.onTrue is not None:
                for s in self.onTrue:
                    s.bake(macro)
        else:
            if self.onFalse is not None:
                for s in self.onFalse:
                    s.bake(macro)

class TON(STATEMENT):
    def __init__(self, timer:TIMER):
        self.timer = timer
        super().__init__(timer)
        self.body = IF(self.timer.EN)(
            IF(~self.timer.TT & ~self.timer.DN)(
                self.timer.ACC.set(0),
                self.timer.TT.set(True),
                self.timer.DN.set(False),
            ),
            IF(~self.timer.DN & self.timer.ACC <= self.timer.PRE)(
                self.timer.ACC.set(self.timer.ACC + 100)
            ).ELSE()(
                self.timer.DN.set(True),
                self.timer.TT.set(False)
            )
        ).ELSE()(
            self.timer.DN.set(False),
            self.timer.ACC.set(0),
            self.timer.TT.set(False),
        )
    
    def bake(self, macro:Macro):
        self.body.bake(macro)
        
    def process(self, macro:Macro):
        self.body.process(macro)

class TIMER(Resource):
    def __init__(self, name:str):
        self.name = name
        self.EN = vbool(f'{name}_EN')
        self.TT = vbool(f'{name}_TT')
        self.DN = vbool(f'{name}_DN')
        self.PRE = vint(f'{name}_PRE')
        self.ACC = vint(f'{name}_ACC')
        super().__init__(self.EN, self.TT, self.DN, self.PRE, self.ACC)
        
    def GetData(self, address:str) -> List[STATEMENT]:
        return [
            *[GetData(var, PLC_NAME, f'{address}.{suffix}') for var, suffix in {
                self.EN : 'EN',
                self.TT : 'TT',
                self.DN : 'DN',
                self.PRE : 'PRE',
                self.ACC : 'ACC',
            }.items()]
        ]
        
    def SetData(self, address:str) -> List[STATEMENT]:
        return [
            *[SetData(var, PLC_NAME, f'{address}.{suffix}') for var, suffix in {
                self.EN : 'EN',
                self.TT : 'TT',
                self.DN : 'DN',
                self.PRE : 'PRE',
                self.ACC : 'ACC',
            }.items()]
        ]
        
    def TON(self) -> TON:
        return TON(self)
        

def SetData(send_data:Variable, device_name:str, address_name:str, data_count:int = 1) -> CALL:
    return CALL('SetData', send_data, device_name, address_name, data_count)

def SetDataEx(send_data:Variable, device_name:str, address_name:str, data_count:int = 1) -> CALL:
    return CALL('SetDataEx', send_data, device_name, address_name, data_count)

def GetData(read_data:Variable, device_name:str, address_name:str, data_count:int = 1) -> CALL:
    return CALL('GetData', read_data, device_name, address_name, data_count)

def GetDataEx(read_data:Variable, device_name:str, address_name:str, data_count:int = 1) -> CALL:
    return CALL('GetDataEx', read_data, device_name, address_name, data_count)

def GetError(error:Variable[int]) -> CALL:
    return CALL('GetError', error)

def DELAY(delay:Union[Variable[int], int]) -> CALL:
    return CALL('DELAY', delay)

def ASYNC_TRIG_MACRO(macro:str) -> CALL:
    return CALL('ASYNC_TRIG_MACRO', macro)

def MIN(arr:Variable[DT], result:Variable[DT], count:int = 1) -> CALL:
    return CALL('MIN', arr, result, count)

def MAX(arr:Variable[DT], result:Variable[DT], count:int = 1) -> CALL:
    return CALL('MAX', arr, result, count)

def C_MIN(a:Union[DT, Variable[DT]], b:Union[DT, Variable[DT]], r:Variable[DT]) -> STATEMENT:
    if isinstance(a, Variable):
        return IF(a <= b)(r.set(a)).ELSE()(r.set(b))
    if isinstance(b, Variable):
        return IF(b > a)(r.set(a)).ELSE()(r.set(b))
    if a <= b:
        return r.set(a)
    return r.set(b)

def C_MAX(a:Union[DT, Variable[DT]], b:Union[DT, Variable[DT]], r:Variable[DT]) -> STATEMENT:
    if isinstance(a, Variable):
        return IF(a > b)(r.set(a)).ELSE()(r.set(b))
    if isinstance(b, Variable):
        return IF(b <= a)(r.set(a)).ELSE()(r.set(b))
    if a > b:
        return r.set(a)
    return r.set(b)